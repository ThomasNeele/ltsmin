%include {
#include <hre/config.h>
#include <assert.h>
#include <stdlib.h>

#include <hre-io/stream.h>
#include <hre/user.h>
#include <hre/stringindex.h>
#include <util-lib/chunk_support.h>
#include <ltsmin-lib/exp-parse-env.h>
#include <ltsmin-lib/exp-syntax.h>
#include <ltsmin-lib/exp-grammar.h>
}

/* Section common parser configuration.

This section is shared by the parsers for all LTSmin languages.
*/

%name expParse
%token_prefix TOKEN_
%token_type { int }
%syntax_error {
    (void)yymajor;(void)yyminor;
    if (env->lineno == 0) {
        HREmessage(error,"%s: syntax error near pos %d", env->filename, env->linepos+1);
    } else {
        HREmessage(error,"%s: syntax error near line %d, pos %d. Token: %s", env->filename, env->lineno+1,env->linepos+1, yyTokenName[TOKEN]);
    }
}
%parse_failure { HREabort(0); }
%parse_accept { Warning(infoLong,"success!"); }
%extra_argument { exp_parse_env_t env }
%stack_overflow {
    (void)yypMinor;
    Abort("stack overflow");
}

/* Section EXP grammar

This section contains the grammar definition of EXP.
*/

input ::= exp_spec(E) . {
    Warning(infoLong,"parsing finished");
    env->model = E;
    Warning(debug,"EXP model has %d processes", E->num_processes);
    Warning(debug,"EXP model has %d syncronization rules", E->num_sync_rules);
}
input ::= ERROR . {
    Abort("The error token is meant to give the lexer a way of passing the error.");
}

exp_spec(E) ::= PAR sync_actions(S) IN proc_section(P) END PAR . {
    E = RTmalloc(sizeof(struct exp_model_s));
    E->num_processes = expListLength(P);
    E->processes = (struct exp_model_s*) expListToArray(P, sizeof(struct exp_model_s));
    E->sync_rules = exp_sync_actions_to_rules(S, E);
    exp_collect_action_labels(E);
    exp_collect_gates(E);
}
exp_spec(E) ::= PAR USING sync_vectors(S) IN proc_section(P) END PAR . {
    E = RTmalloc(sizeof(struct exp_model_s));
    E->num_processes = expListLength(P);
    E->processes = (struct exp_model_s*) expListToArray(P, sizeof(struct exp_model_s));
    E->num_sync_rules = expListLength(S);
    E->sync_rules = (char***) expListToArray(S, sizeof(char**));
    exp_collect_action_labels(E);
    exp_collect_gates(E);
}
exp_spec(E) ::= DES LPAR NUMBER(INITIAL_STATE) COMMA NUMBER(num_transitions) COMMA NUMBER(num_states) RPAR trans_list(Tr) . {
    char*** transitions = RTmallocZero(sizeof(char**) * num_states);
    list_t current = Tr;
    string_index_t action_labels = SIcreate();
    while(current) {
        transition_t current_trans = current->item;
        if(transitions[current_trans->source] == NULL) {
            transitions[current_trans->source] = RTmallocZero(sizeof(char*) * num_states);
        }
        if(transitions[current_trans->source][current_trans->destination]) {
            char* appended_label = RTmalloc(sizeof(char) * strlen(transitions[current_trans->source][current_trans->destination]) + 2 + strlen(current_trans->label));
            sprintf(appended_label, "%s\x1f%s", transitions[current_trans->source][current_trans->destination], current_trans->label);
            if(strchr(transitions[current_trans->source][current_trans->destination], '\x1f')) {
                // This is an appended string, so it can be freed
                RTfree(transitions[current_trans->source][current_trans->destination]);
            }
            transitions[current_trans->source][current_trans->destination] = appended_label;
        } else {
            transitions[current_trans->source][current_trans->destination] = current_trans->label;
        }
        SIput(action_labels, current_trans->label);
        list_t prev = current->prev;
        RTfree(current);
        current = prev;
    }
    E = RTmalloc(sizeof(struct exp_model_s));
    E->num_processes = 0;
    E->action_labels = action_labels;
    E->process_states = num_states;
    E->process_transitions = num_transitions;
    E->initial_state = INITIAL_STATE;
    E->transitions = transitions;
    exp_collect_gates(E);

}
exp_spec(E) ::= STRING(filename) . {
    E = exp_recur_parse_stream(env->scanner, SIget( env->strings, filename) );
}

exp_spec ::= error . {
    HREprintf (error, "EXP syntax error.\n");
    HREabort(0);
}

sync_actions(L) ::= sync_actions(A) COMMA sync_action(B) . {
    L = expAddList(A,B);
}
sync_actions(L) ::= sync_action(A) . {
    L = expAddList(NULL, A);
}
sync_action(A) ::= ACTION(B) HASH NUMBER(C) . {
    char* label = SIget(env->strings, B);
    A = RTmalloc(sizeof(struct sync_action_number_s));
    A->label = label;
    A->number = C;
}
sync_action(A) ::= ACTION(B) . {
    char* label = SIget(env->strings, B);
    A = RTmalloc(sizeof(struct sync_action_number_s));
    A->label = label;
    A->number = 2;
}

sync_vectors(L) ::= sync_vectors(A) COMMA sync_rule(B) . {
    char*** a = RTmalloc(sizeof(char**));
    *a = B;
    L = expAddList(A,a);
}
sync_vectors(L) ::= sync_rule(A) . {
    char*** a = RTmalloc(sizeof(char**));
    *a = A;
    L = expAddList(NULL,a);
}
sync_rule(R) ::= actions(A) ARROW ACTION(B) . {
    char** a = RTmalloc(sizeof(char*));
    *a = SIget(env->strings, B);
    list_t action_list = expAddList(A,a);
    R = (char**) expListToArray(action_list, sizeof(char*));
}
actions(L) ::= actions(A) STAR action(B) . { char** a = RTmalloc(sizeof(char*)); *a = B; L = expAddList(A,a); }
actions(L) ::= action(A) . { char** a = RTmalloc(sizeof(char*)); *a = A; L = expAddList(NULL,a); }
action(A) ::= UNDERSCORE . { A = NULL; }
action(A) ::= ACTION(B) . { A = SIget(env->strings, B); }

proc_section(L) ::= proc_section(A) BARS exp_spec(B) . { L = expAddList(A,B); }
proc_section(L) ::= exp_spec(A) . { L = expAddList(NULL,A); }


trans_list(L) ::= trans_list(A) trans(T) . { L = expAddList(A,T); }
trans_list(L) ::= . { L = NULL; }
trans(Tr) ::= LPAR NUMBER(S) COMMA STRING(A) COMMA NUMBER(T) RPAR . {
    transition_t trans = RTmalloc(sizeof(struct transition_s));
    trans->source = S;
    trans->label = SIget(env->strings, A);
    trans->destination = T;
    Tr = trans;
}
trans(Tr) ::= LPAR NUMBER(S) COMMA ACTION(A) COMMA NUMBER(T) RPAR . {
    transition_t trans = RTmalloc(sizeof(struct transition_s));
    trans->source = S;
    trans->label = SIget(env->strings, A);
    trans->destination = T;
    Tr = trans;
}

%type exp_spec { exp_model_t }
%destructor exp_spec {
    if($$->sync_rules)
        RTfree($$->sync_rules);
    if($$->processes)
        RTfree($$->processes);
    if($$->transitions)
        RTfree($$->transitions);
}

%type sync_actions { list_t }
%destructor sync_actions { expListFree($$); }
%type sync_action { sync_action_number_t }
%destructor sync_action { RTfree($$); }
%type sync_vectors { list_t }
%destructor sync_vectors { expListFree($$); }
%type sync_rule { char** }
%destructor sync_rule { RTfree($$); }
%type actions { list_t }
%destructor actions { expListFree($$); }
%type action { char* }
%destructor action { if($$) {RTfree($$);} }

%type proc_section { list_t }
%destructor proc_section { expListFree($$); }
%type trans_list { list_t }
%destructor trans_list { expListFree($$); }
%type trans { transition_t }
%destructor trans { RTfree($$->label); RTfree($$); }


%left ARROW .
%left STAR .

%left BARS .

/* generates a special USER token so that the user knows the value of the last reserved token */
/* must be at the end of the file */
%left USER
